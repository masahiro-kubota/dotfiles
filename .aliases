alias d='cd ~/Documents'

alias ..2='cd ../..'
alias ..3='cd ../../..'

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

alias g='git'
alias ga='git add'
alias ga.='git add .'
alias gd='git diff'
alias gs='git status'
alias gpsod='git push origin dev'
alias gpsom='git push origin main'
alias gb='git branch'
alias gf='git fetch'
alias gch='git checkout'
alias gcm='git commit -m'
alias gplod='git pull origin dev'
alias gplom='git pull origin main'
alias glo='git log --oneline'


scs() { sudo systemctl status "$1"; }
scr() { sudo systemctl restart "$1"; }
scst() { sudo systemctl start "$1"; }
scsp() { sudo systemctl stop "$1"; }

jfu() { journalctl -fu "$1"; }
js()  { journalctl -u "$1" -xe; }

# Git worktree aliases
gwb() {
  WORKTREE_PATH=../$(basename $(pwd))-${1}
  git worktree add $WORKTREE_PATH $2
}
alias gwd='git worktree remove'


# dotfiles
alias bashrc='source ~/.bashrc'
alias zshrc='source ~/.zshrc'

# ros
# ros2 run logging_demo logging_demo_main 2>&1 | tslog
alias tslog='while read line; do echo "$(date "+[%Y-%m-%d %H:%M:%S.%3N]") $line"; done'
alias psim='mkdir -p psim_log && ros2 launch autoware_launch planning_simulator.launch.xml 2>&1 | tslog > psim_log/`date +%m_%d_%H_%M_%S`.log'
alias si='source install/setup.bash'
alias rl='ros2 launch'
alias rr='ros2 run'

# showcmd: ã‚³ãƒãƒ³ãƒ‰ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’èª¿ã¹ã‚‹
showcmd() {
  if [ -z "$1" ]; then
    echo "Usage: showcmd <command>"
    return 1
  fi

  local cmd="$1"

  # å®Ÿä½“ãƒ‘ã‚¹å–å¾—
  local cmdpath
  cmdpath=$(command -v -- "$cmd" 2>/dev/null)
  if [ -z "$cmdpath" ]; then
    echo "Command not found: $cmd"
    return 1
  fi

  # ã‚·ã‚§ãƒ«ãƒ“ãƒ«ãƒˆã‚¤ãƒ³åˆ¤å®š
  if type "$cmd" 2>/dev/null | grep -q "shell builtin"; then
    echo "'$cmd' ã¯ã‚·ã‚§ãƒ«ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã§ã™ï¼ˆãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç®¡ç†å¯¾è±¡å¤–ï¼‰"
    return 0
  fi

  # å€™è£œãƒ‘ã‚¹:
  #  1) command -v ã®çµæœ
  #  2) readlink -f ã—ãŸå®Ÿä½“ï¼ˆã‚ã‚Œã°ï¼‰
  local real
  real=$(readlink -f -- "$cmdpath" 2>/dev/null || echo "")

  local pkg=""
  local p

  for p in "$cmdpath" "$real"; do
    [ -z "$p" ] && continue
    pkg=$(dpkg -S "$p" 2>/dev/null | head -n1 | cut -d: -f1)
    [ -n "$pkg" ] && break
  done

  # ã¾ã è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ basename ã§æ¤œç´¢ï¼ˆ/bin/ip ã‚„ /usr/bin/ip ã‚’æ‹¾ã†ï¼‰
  if [ -z "$pkg" ]; then
    local base
    base=$(basename -- "$cmdpath")
    pkg=$(dpkg -S "$base" 2>/dev/null | grep -E "/(sbin|bin)/$base\$" | head -n1 | cut -d: -f1)
  fi

  if [ -z "$pkg" ]; then
    echo "dpkg -S ã§ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"
    echo "  è©¦ã—ãŸãƒ‘ã‚¹: $cmdpath${real:+, $real}"
    echo "  -> æ‰‹å‹•ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ« or snap or /usr/local/... ç”±æ¥ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"
    return 1
  fi

  echo "ğŸ” Command: $cmd"
  echo "ğŸ“„ Path:    $cmdpath"
  [ -n "$real" ] && echo "ğŸ“„ Real:    $real"
  echo "ğŸ“¦ Package: $pkg"
  echo "â€”â€” apt policy â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”"
  apt policy "$pkg"
}
