# 新規タスク実装ワークフロー

## タスク概要
**実装内容**: $ARGUMENTS

## Phase 1: 準備フェーズ

### 1. ブランチ作成
```bash
# mainブランチから最新の状態で作業ブランチを作成
git checkout main
git pull origin main
git checkout -b feature/task-name-here
```

### 2. タスク分析と設計
以下の観点でタスクを分析し、実装方針を決定：

- **要件整理**: 何を実装するのか、どのような動作が期待されるか
- **影響範囲**: 変更が必要なファイル・モジュールの特定

### 3. PR分割判定
実装内容が大きい場合、以下の観点でPR分割を検討：

#### 分割が必要な場合の判定基準
- **変更ファイル数**: 10ファイル以上の変更が必要
- **機能の独立性**: 複数の独立した機能が含まれる
- **レビュー負荷**: 単一PRでのレビューが困難な規模

## Phase 2: コミット計画策定

### 4. コミット分割計画の作成
**現在のPR範囲内で**タスクを以下の観点で複数のコミットに分割：

1. **準備コミット** (Setup)
   - 依存関係の追加
   - 設定ファイルの更新
   - ディレクトリ構造の変更

2. **コア実装コミット** (Core Implementation)  
   - メイン機能の実装
   - 必要に応じて更に細分化

3. **テストコミット** (Tests)
   - テストは重要な機能のみで大丈夫です

### 各コミットの確認項目テンプレート
```
コミット: [type](scope): description

確認項目:
- [ ] コードが正常に動作する
- [ ] 既存機能に悪影響がない
- [ ] テストが通る (該当する場合)
- [ ] リンターエラーがない
- [ ] pre-commitフックが通る
- [ ] コミットメッセージがConventional Commits形式
```

## Phase 3: 実装フェーズ

### 5. 順次実装・コミット
各コミット計画に従って以下の手順で実装：

1. **実装**
   - 計画したコミット単位で実装
   - 小さく、原子的な変更を心がける

2. **確認**
   - 上記の確認項目をすべてチェック
   - ローカルでテスト実行
   - 動作確認の実施

3. **コミット**
   ```bash
   git add .
   git commit -m "feat(scope): implement feature description"
   ```

4. **次のコミットへ**
   - 全コミットが完了するまで繰り返し

## Phase 4: 完了フェーズ

### 6. 最終確認
- [ ] 全てのコミットが計画通り完了している
- [ ] 全体の動作テストが通る
- [ ] ドキュメントが更新されている
- [ ] 不要なファイルやコメントが残っていない

### 7. プッシュ
```bash
git push origin feature/task-name-here
```

### 8. プルリクエスト作成
**現在のPR範囲の実装とテストが完了したら:**
```
/make-pull-request
```

### 9. 後続PR計画
**分割PRの場合**: 現在のPRがマージされた後、次のPRの実装に着手

## 注意事項
- **適切なPR粒度**: レビュアーが理解・検証しやすいサイズに分割
- 各コミットは独立して動作可能な状態にする
- コミットメッセージはConventional Commits形式を厳守
- 大きな変更は複数のPRに分割することを躊躇しない
- 各段階で十分なテストと確認を行う
- 問題が発生した場合は早めに相談する
